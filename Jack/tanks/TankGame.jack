/**
 * The actual tank game
 */
class TankGame
{
	// Level handler
	field Level level;

	// Player 1
	field Player player1;

	// Player 2
	field Player player2;

	// Whether it's player 1's turn
	field boolean player1Turn;

	// Whether game is waiting for player to begin turn (press enter)
	field boolean playerTurnWaiting;

	// Number of moves remaining for player turn
	field int movesRemaining;

	// Max shooting distance
	field int maxShootingDistance;

	// Current player scores
	field int player1Score;
	field int player2Score;

	// whether it's the start of a new round
	field boolean newRound;

	/**
	 * Create a new tank game
	 */
	constructor TankGame new()
	{
		// create a new Level object
		let level = Level.new();

		// init player1
		let player1 = Player.new(this, 1);

		// init player2
		let player2 = Player.new(this, 2);

		// load the first level
		do loadLevel(1);

		return this;
	}

	/**
	 * Load a new level
	 * @param int levelToLoad
	 */ 
	method void loadLevel(int levelToLoad)
	{
		// load level
		do level.loadLevel(levelToLoad);

		let maxShootingDistance = level.getMaxShootingDistance();

		// player 1 gets first go
		let player1Turn = true;

		// reset moves remaining
		do updateMovesRemaining();

		// reset score
		do resetScore();

		// remove players before drawing the level, else player removal 
		// afterwards potentially leaves spaces in level geometry
		do player1.remove();
		do player2.remove();

		// and display it
		do level.draw();

		// reset players
		do resetPlayerPositions();

		return;
	}

	/**
	 * Get max shooting distance for current level 
	 * used in player.shoot()
	 */
	method int getMaxShootingDistance()
	{
		return maxShootingDistance;
	}

	/**
	 * Reset scores and update on screen
	 */
	method void resetScore()
	{
		let player1Score = 0;
		let player2Score = 0;

		do Output.moveCursor(1, 5);
		do Output.printInt(0);
		do Output.moveCursor(1, 58);
		do Output.printInt(0);

		return;
	}

	/**
	 * set score and update on screen
	 */
	method void setScore(int score)
	{
		if (player1Turn) {
			do Output.moveCursor(1, 5);
			do Output.printInt(score);
		} else {
			do Output.moveCursor(1, 58);
			do Output.printInt(score);
		}

		return;
	}

	/**
	 * Update moves remaining text
	 */
	method void updateMovesRemaining()
	{
		do Output.moveCursor(1, 19);
		// clear
		do Main.printString("                                  ");
		do Output.moveCursor(1, 19);

		if (player1Turn) {
			do Main.printString("Player 1: ");
		} else {
			do Main.printString("Player 2: ");
		}

		do Output.printInt(movesRemaining);

		if (movesRemaining = 1) {
			do Main.printString(" move remains.");
		} else {
			do Main.printString(" moves remain.");
		}

		return;
	}

	/**
	 * Switch player turn + reset moves remaining for next player's turn
	 */ 
	method void nextTurn()
	{
		let playerTurnWaiting = false;
		let movesRemaining = level.getMovesPerTurn();
		do Output.moveCursor(1, 9);

		// clear
		do Main.printString("                                              ");

		do updateMovesRemaining();

		return;
	}

	/**
	 * Decrement player moves remaining count 
	 * and check whether they have any moves remaining
	 */
	method boolean decrementAndCheckMovesRemaining()
	{
		if (newRound) {
			return false;
		}

		let movesRemaining = movesRemaining - 1;
		do updateMovesRemaining();

		if (movesRemaining = 0) {
			do turnOver();
			return false; 
		}

		return true;
	}

	/**
	 * Player turn over, control goes to next player
	 */
	method void turnOver()
	{
		let player1Turn = ~player1Turn;
		let playerTurnWaiting = true;

		do Output.moveCursor(1, 9);
		// clear
		do Main.printString("                                              ");
		do Output.moveCursor(1, 9);

		if (player1Turn) {
			do Main.printString("Player 1");
		} else {
			do Main.printString("Player 2");
		}

		do Main.printString(" your turn! Press [ENTER] to continue.");

		return;
	}

	/**
	 * Detect whether player is colliding with other player (or shooting at them)
	 * @param int x
	 * @param int y
	 * @param boolean isShooting
	 */
	method boolean detectPlayerCollision(int x, int y, boolean isShooting)
	{
		var boolean collided;
		let collided = false;

		if (player1Turn) {
			// check against player 2
			let collided = player2.detectCollision(x, y);
		} else {
			// check against player 1
			let collided = player1.detectCollision(x, y);
		}

		if (isShooting & collided) {
			// player got shot, so end round
			do playerKilled();
		} 

		return collided;
	}

	/**
	 * Reset player sprites to level-specific positions
	 */
	method void resetPlayerPositions()
	{
		// reset start locations, and use the fancy tank load animation
		do player1.setLocationAndDirection(level.getPlayer1StartX(), level.getPlayer1StartY(), level.getPlayer1StartDirection(), true);
		do player2.setLocationAndDirection(level.getPlayer2StartX(), level.getPlayer2StartY(), level.getPlayer2StartDirection(), true);

		// new round, player that last won goes first
		let newRound = true;
		do nextTurn();
		return;
	}

	/**
	 * Deal with player killed
	 * increment score where game not over and deal with game over scenario (score = 10)
	 */
	method void playerKilled()
	{
		// max 10 points per game
		if (player2Score = 10 | player1Score = 10) {
			// GAME OVER!
			return;
		}

		if (player1Turn) {
			// increment player1 score
			let player1Score = player1Score + 1;
			do setScore(player1Score);

			// display simple explosion animation on player2 
			do player2.explode();
		} else {
			let player2Score = player2Score + 1;
			do setScore(player2Score);
			do player1.explode();
		}

		do resetPlayerPositions();

		return;
	}

	/**
	 * Detect level geometry collision and determine whether it's an object that can be destroyed
	 * @param int x
	 * @param int y
	 * @param boolean isShooting
	 */
	method boolean detectLevelCollision(int x, int y, boolean isShooting)
	{
		var int levelItemDetected;
		let levelItemDetected = level.detectCollision(x, y);

		// we only remove destructable items if the player is shooting at it
		if (isShooting) {
			// TODO, potentially replace with generic "breakable" + "shootToBreakCount" 
			if (levelItemDetected = 1) {
				// concrete wall, can be destroyed
				do level.removeSprite(x, y);
			}
		}

		return levelItemDetected > 0;
	}

	/**
	 * Game Loop
	 */
	method void run()
	{
		var boolean exit;					

		// the key currently pressed by the user
	    var char key;  						

		let exit = false;				

		// game loop
		while (~exit) {
			// waits for a key to be pressed
			while (key = 0) {
				let key = Keyboard.keyPressed();
			}

			// Q key
			if (key = 81) { 
				let exit = true; 
			} else {
				// Z key
				if (key = 90) {
					// load next level
					do loadLevel(level.getCurrentLevel() + 1);	
				} else  {
					// player keys
					if (~playerTurnWaiting) {
						// pass key through to player objects
						let newRound = false;

						if (player1Turn) {
							do player1.keyPressed(key);
						} else {
							do player2.keyPressed(key);
						} 

						// check whether player has moves still this turn
						do decrementAndCheckMovesRemaining();
					} else {
						// check that next player acknowledges turn
						if (key = 128) {
							do nextTurn();
						}
					}				
				}

				// key debounce.
				// since this is a turn-based game we don't want the player to hold the keys down
				while (~(key = 0)) {
					do Sys.wait(40);
					let key = Keyboard.keyPressed();
				}

			}
		}

		return;
	}

	/**
	 * Clean up
	 */
	method void dispose()
	{
		do player1.dispose();
		do player2.dispose();
		do level.dispose();

		do Memory.deAlloc(this);
		return;
	}

}